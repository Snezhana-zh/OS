Файлы и Файловые системы
1. Написать программу, которая копирует каталог “задом наперед”. Программа
получает в качестве аргумента путь к каталогу. Далее:
a. Программа создает каталог с именем заданного каталога, прочитанного
наоборот. Если задан каталог “qwerty”, то должен быть создан каталог
“ytrewq”.
b. Программа копирует все регулярные файлы из исходного каталога в
целевой (пропуская файлы другого типа), переворачивая их имена и
содержимое. То есть с именами файлов поступаем также как и с именем
каталога, а содержимое копируется начиная с последнего байта и до
нулевого.
2. Написать программу, которая создает, читает, изменяет права доступа и
удаляет следующие объекты: файлы, каталоги, символьные и жесткие ссылки.
Для определения того какая именно функция должна быть исполнена
предлагается иметь необходимое количество жестких ссылок на исполняемый
файл с именами соответствующими выполняемому действию и в программе
выполнять функцию соответствующую имени жесткой ссылки. Программа
должна уметь:
a. создать каталог, указанный в аргументе;
b. вывести содержимое каталога, указанного в аргументе;
c. удалить каталог, указанный в аргументе;
d. создать файл, указанный в аргументе;
e. вывести содержимое файла, указанного в аргументе;
f. удалить файл, указанный в аргументе;
g. создать символьную ссылку на файл, указанный в аргументе;
h. вывести содержимое символьной ссылки, указанный в аргументе;
i. вывести содержимое файла, на который указывает символьная ссылка,
указанная в аргументе;
j. удалить символьную ссылку на файл, указанный в аргументе;
k. создать жесткую ссылку на файл, указанный в аргументе;
l. удалить жесткую ссылку на файл, указанный в аргументе;
m. вывести права доступа к файлу, указанному в аргументе и количество
жестких ссылок на него;
n. изменить права доступа к файлу, указанному в аргументе.
3. Написать программу, которая выводит содержимое /proc/pid/pagemap
Адресное пространство процесса
1. Структура адресного пространства.
a. Напишите программу, которая создает переменные и выводит их адреса:
i. локальные в функции;
ii. статические в функции;
iii. константы в функции;
iv. глобальные инициализированные;
v. глобальные неинициализированные;
vi. глобальные константы.
b. Сопоставьте адреса переменных с областями адресного пространства из
соответствующего /proc/<pid>/maps. Объясните увиденное.
c. Используя утилиту nm (или readelf) определите в каких секциях
находятся выделенные переменные переменные.
d. Напишите функцию, которая создает и инициализирует локальную
переменную и возвращает ее адрес. Прокомментируйте результат и
дайте оценку происходящему.
e. Напишите функцию, которая:
i. выделяет на куче буфер (например, размером 100 байт);
ii. записывает в него какую-либо фразу (например, hello world);
iii. выводит содержимое буфера;
iv. освобождает выделенную память;
v. снова выводит содержимое буфера;
vi. выделяет еще один буфер;
vii. записывает в них какую-либо фразу (например, hello world);
viii. выводит содержимое буфера;
ix. перемещает указатель на середину буфера;
x. освобождает память по этому указателю.
xi. выводит содержимое буфера;
f. Прокомментируйте работу предыдущего пункта.
g. Заведите переменную окружения.
h. Добавьте в вашу программу код, который:
i. распечатывает ее значение;
ii. изменяет его значение;
iii. повторно распечатывает ее значение.
i. Запустите вашу программу и убедитесь что переменная окружения
имеет требуемое значение.
j. Выведите значение переменной окружения после того как ваша
программа завершилась.
k. Объясните произошедшее.
2. Управление адресным пространством:
a. Напишите программу, которая:
i. выводит pid процесса;
ii. ждет одну секунду;
iii. делает exec(2) самой себя;
iv. выводит сообщение “Hello world”
b. Понаблюдайте за выводом программы и содержимым соответствующего
файла /proc/<pid>/maps. Объясните происходящее.
c. Напишите программу, которая:
i. выводит pid процесса;
ii. ждет 10 секунд (подберите паузу чтобы успеть начать мониторить
адресное пространство процесса, например, watch cat
/proc/<pid>/maps);
iii. напишите функцию, которая будет выделять на стеке массив
(например, 4096 байт) и рекурсивно вызывать себя;
iv. понаблюдайте как изменяется адресное пространство процесса
(стек);
v. напишите цикл, в котором на каждой итерации будет выделяться
память на куче (подберите размер буфера сами). Используйте
секундную паузу между итерациями.
vi. понаблюдайте как изменится адресное пространство процесса
(heap);
vii. освободите занятую память.
viii. присоедините к процессу еще один регион адресов размером в 10
страниц (используйте mmap(2) с флагом ANONYMOUS).
ix. понаблюдайте за адресным пространством.
x. измените права доступа к созданному региону и проверьте какая
будет реакция, если их нарушить:
1. запретите читать данные и попробуйте прочитать из
региона.
2. запретите писать и попробуйте записать.
xi. попробуйте перехватить сигнал SIGSEGV.
xii. отсоедините страницы с 4 по 6 в созданном вами регионе.
xiii. понаблюдайте за адресным пространством.
d. Чтобы было удобнее наблюдать за адресным пространством подберите
удобные паузы между операциями изменяющими его.
e. Объясните что происходит с адресным пространством в данной задаче.
3. Самодельная куча
a. Реализуйте свою кучу над анонимным регионом адресов:
i. присоедините анонимный регион (mmap(2));
ii. реализуйте функцию my_malloc(), которая:
1. принимает размер памяти в байтах;
2. резервирует буфер запрошенного размера и возвращает
указатель на его начало;
3. при недостатке памяти возвращает NULL.
iii. реализуйте функцию my_free(), которая:
1. принимает указатель на буфер, возвращенный ранее
функцией my_malloc();
2. помечает буфер свободным;
iv. Рекомендация. Для отладки можно присоединить регион
связанный с файлом. Это позволит наблюдать за состоянием
вашей кучи при выделении-освобождении памяти.
